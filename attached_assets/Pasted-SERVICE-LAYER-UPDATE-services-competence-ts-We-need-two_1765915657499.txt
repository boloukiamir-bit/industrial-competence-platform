SERVICE LAYER – UPDATE services/competence.ts

We need two things:

Make getEmployeeCompetenceProfile date-aware (optional parameter)

Add a helper to compute coverage per position for a given date

2.1. Make getEmployeeCompetenceProfile date-aware

Currently getEmployeeCompetenceProfile internally computes "today" and compares valid_to against todayStr.

Refactor the signature to:

export async function getEmployeeCompetenceProfile(
  employeeId: string,
  effectiveDate?: string
): Promise<EmployeeCompetenceProfile>


Inside the function:

Replace the internal today / todayStr logic with:

const effectiveDateStr =
  effectiveDate ?? new Date().toISOString().slice(0, 10);


In the helper function isExpired(validTo: string | null): boolean use effectiveDateStr instead of todayStr:

function isExpired(validTo: string | null): boolean {
  if (!validTo) return false;
  return validTo < effectiveDateStr;
}


Do NOT change any other semantics.

All existing call sites should continue to work without passing effectiveDate (they use “today” by default).

2.2. Add PositionCoverageSummary types and function

Extend services/competence.ts with:

export type PositionCoverageSummary = {
  positionId: string;
  positionName: string;
  site: string | null;
  department: string | null;
  minHeadcount: number;
  availableCount: number;
  gap: number; // max(0, minHeadcount - availableCount)
  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
};


Add a helper function to compute coverage for a specific date (YYYY-MM-DD):

export async function getPositionCoverageForDate(
  effectiveDate: string
): Promise<PositionCoverageSummary[]> {
  // 1) Load positions with min_headcount > 0
  const { data: posData, error: posError } = await supabase
    .from('positions')
    .select('id, name, site, department, min_headcount')
    .gt('min_headcount', 0);

  if (posError) throw posError;

  const positions = (posData ?? []).map((p: any) => ({
    id: p.id as string,
    name: p.name as string,
    site: (p.site ?? null) as string | null,
    department: (p.department ?? null) as string | null,
    minHeadcount: p.min_headcount as number,
  }));

  const results: PositionCoverageSummary[] = [];

  for (const pos of positions) {
    // 2) Get employees in this position
    const employees = await getEmployeesForPosition(pos.id);

    if (employees.length === 0) {
      // No employees → high risk and full gap (minHeadcount)
      results.push({
        positionId: pos.id,
        positionName: pos.name,
        site: pos.site,
        department: pos.department,
        minHeadcount: pos.minHeadcount,
        availableCount: 0,
        gap: pos.minHeadcount,
        riskLevel: 'HIGH',
      });
      continue;
    }

    // 3) For each employee, use their competence profile at effectiveDate
    let availableCount = 0;

    for (const emp of employees) {
      const profile = await getEmployeeCompetenceProfile(
        emp.id,
        effectiveDate
      );

      // Fully competent = no gaps on mandatory competences
      const isFullyCompetent = profile.summary.gapCount === 0;

      if (isFullyCompetent) {
        availableCount += 1;
      }
    }

    const gap = Math.max(0, pos.minHeadcount - availableCount);

    // 4) Risk level logic:
    // - HIGH: gap > 0 AND availableCount === 0
    // - MEDIUM: gap > 0 BUT availableCount > 0
    // - LOW:   gap === 0
    let riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' = 'LOW';
    if (gap > 0 && availableCount === 0) {
      riskLevel = 'HIGH';
    } else if (gap > 0) {
      riskLevel = 'MEDIUM';
    } else {
      riskLevel = 'LOW';
    }

    results.push({
      positionId: pos.id,
      positionName: pos.name,
      site: pos.site,
      department: pos.department,
      minHeadcount: pos.minHeadcount,
      availableCount,
      gap,
      riskLevel,
    });
  }

  // Sort: HIGH risk first, then MEDIUM, then LOW
  const riskRank: Record<'LOW' | 'MEDIUM' | 'HIGH', number> = {
    HIGH: 0,
    MEDIUM: 1,
    LOW: 2,
  };

  results.sort((a, b) => {
    const rDiff = riskRank[a.riskLevel] - riskRank[b.riskLevel];
    if (rDiff !== 0) return rDiff;
    return a.positionName.localeCompare(b.positionName);
  });

  return results;
}


Important:

Keep this function generic for any date.

Tomorrow’s Gaps page will compute tomorrow’s date string and call this.