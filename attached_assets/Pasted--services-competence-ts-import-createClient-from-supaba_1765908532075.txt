// services/competence.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

const supabase = createClient(supabaseUrl, supabaseAnonKey);

export type EmployeeCompetenceItem = {
  competenceId: string;
  competenceName: string;
  competenceCode: string | null;
  groupName: string | null;
  requiredLevel: number | null;
  mandatory: boolean;
  employeeLevel: number | null;
  validTo: string | null;
  status: 'OK' | 'RISK' | 'N/A';
  riskReason: string | null;
  isSafetyCritical: boolean;
};

export type EmployeeCompetenceSummary = {
  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
  gapCount: number;
  totalRequired: number;
  coveragePercent: number; // 0–100
  expiredCount: number;
};

export type EmployeeCompetenceProfile = {
  employee: {
    id: string;
    name: string;
    positionName: string | null;
  };
  summary: EmployeeCompetenceSummary;
  items: EmployeeCompetenceItem[];
};

type EmployeeRow = {
  id: string;
  full_name?: string | null;
  name?: string | null;
  position_id?: string | null;
};

type RequirementRow = {
  id: string;
  position_id: string;
  competence_id: string;
  required_level: number;
  mandatory: boolean;
};

type EmployeeCompetenceRow = {
  id: string;
  employee_id: string;
  competence_id: string;
  level: number;
  valid_from: string | null;
  valid_to: string | null;
};

type CompetenceRow = {
  id: string;
  name: string;
  description?: string | null;
  code?: string | null;
  group_id?: string | null;
  is_safety_critical: boolean;
};

type GroupRow = {
  id: string;
  name: string;
};

export async function getEmployeeCompetenceProfile(
  employeeId: string
): Promise<EmployeeCompetenceProfile> {
  // 1) Employee
  const { data: employeeRow, error: empError } = await supabase
    .from('employees')
    .select('id, full_name, name, position_id')
    .eq('id', employeeId)
    .single<EmployeeRow>();

  if (empError || !employeeRow) {
    console.error(empError);
    throw empError ?? new Error('Employee not found');
  }

  const employeeName =
    employeeRow.full_name ?? employeeRow.name ?? 'Employee';

  // 2) Position (optional)
  let positionName: string | null = null;
  const positionId = employeeRow.position_id ?? null;

  if (positionId) {
    const { data: posRows } = await supabase
      .from('positions')
      .select('id, name')
      .eq('id', positionId)
      .limit(1);

    const pos = posRows?.[0] as { id: string; name: string } | undefined;
    if (pos) {
      positionName = pos.name;
    }
  }

  // 3) Requirements for this position
  let requirementRows: RequirementRow[] = [];
  if (positionId) {
    const { data: reqData, error: reqError } = await supabase
      .from('position_competence_requirements')
      .select('id, position_id, competence_id, required_level, mandatory')
      .eq('position_id', positionId);

    if (reqError) {
      console.error(reqError);
      throw reqError;
    }
    requirementRows = (reqData ?? []) as RequirementRow[];
  }

  // 4) Employee competences
  const { data: empCompData, error: empCompError } = await supabase
    .from('employee_competences')
    .select('id, employee_id, competence_id, level, valid_from, valid_to')
    .eq('employee_id', employeeId);

  if (empCompError) {
    console.error(empCompError);
    throw empCompError;
  }

  const employeeCompRows = (empCompData ?? []) as EmployeeCompetenceRow[];
  const empCompByCompetenceId = new Map<
    string,
    EmployeeCompetenceRow
  >();
  for (const row of employeeCompRows) {
    empCompByCompetenceId.set(row.competence_id, row);
  }

  // 5) Load all involved competences + groups
  const competenceIds = new Set<string>();
  requirementRows.forEach((r) => competenceIds.add(r.competence_id));
  employeeCompRows.forEach((r) => competenceIds.add(r.competence_id));

  const competencesById = new Map<
    string,
    CompetenceRow & { groupName: string | null }
  >();

  if (competenceIds.size > 0) {
    const { data: compData, error: compError } = await supabase
      .from('competences')
      .select('id, name, description, code, group_id, is_safety_critical')
      .in('id', Array.from(competenceIds));

    if (compError) {
      console.error(compError);
      throw compError;
    }

    const comps = (compData ?? []) as CompetenceRow[];

    const groupIds = new Set<string>();
    comps.forEach((c) => {
      if (c.group_id) groupIds.add(c.group_id);
    });

    let groupById = new Map<string, string>();
    if (groupIds.size > 0) {
      const { data: groupData, error: groupError } = await supabase
        .from('competence_groups')
        .select('id, name')
        .in('id', Array.from(groupIds));

      if (groupError) {
        console.error(groupError);
      } else {
        (groupData ?? []).forEach((g) => {
          const gr = g as GroupRow;
          groupById.set(gr.id, gr.name);
        });
      }
    }

    comps.forEach((c) => {
      competencesById.set(c.id, {
        ...c,
        groupName: c.group_id ? groupById.get(c.group_id) ?? null : null,
      });
    });
  }

  const today = new Date();
  const todayStr = today.toISOString().slice(0, 10);

  function isExpired(validTo: string | null): boolean {
    if (!validTo) return false;
    // date-only compare
    return validTo < todayStr;
  }

  const items: EmployeeCompetenceItem[] = [];
  let totalRequired = 0;
  let gapCount = 0;
  let expiredCount = 0;

  const usedCompetenceIds = new Set<string>();

  // 6) Build items for all requirements (rollkrav)
  for (const req of requirementRows) {
    const compInfo = competencesById.get(req.competence_id);
    if (!compInfo) continue;

    const empComp = empCompByCompetenceId.get(req.competence_id) ?? null;

    let status: 'OK' | 'RISK' | 'N/A' = 'N/A';
    let riskReason: string | null = null;
    let empLevel: number | null = empComp ? empComp.level : null;
    const validTo = empComp?.valid_to ?? null;

    if (req.mandatory) {
      totalRequired += 1;

      if (!empComp) {
        status = 'RISK';
        riskReason = 'Saknar kompetens';
        gapCount += 1;
      } else if (isExpired(validTo)) {
        status = 'RISK';
        riskReason = 'Utgången giltighet';
        gapCount += 1;
        expiredCount += 1;
      } else if (empLevel! < req.required_level) {
        status = 'RISK';
        riskReason = 'För låg nivå';
        gapCount += 1;
      } else {
        status = 'OK';
      }
    } else {
      // ej obligatorisk men definierad
      status = empComp ? 'OK' : 'N/A';
    }

    items.push({
      competenceId: compInfo.id,
      competenceName: compInfo.name,
      competenceCode: compInfo.code ?? null,
      groupName: compInfo.groupName,
      requiredLevel: req.required_level,
      mandatory: req.mandatory,
      employeeLevel: empLevel,
      validTo,
      status,
      riskReason,
      isSafetyCritical: compInfo.is_safety_critical,
    });

    usedCompetenceIds.add(compInfo.id);
  }

  // 7) Extra kompetenser som inte finns i rollkraven (nice-to-have / historik)
  for (const empComp of employeeCompRows) {
    if (usedCompetenceIds.has(empComp.competence_id)) continue;
    const compInfo = competencesById.get(empComp.competence_id);
    if (!compInfo) continue;

    items.push({
      competenceId: compInfo.id,
      competenceName: compInfo.name,
      competenceCode: compInfo.code ?? null,
      groupName: compInfo.groupName,
      requiredLevel: null,
      mandatory: false,
      employeeLevel: empComp.level,
      validTo: empComp.valid_to,
      status: isExpired(empComp.valid_to) ? 'RISK' : 'N/A',
      riskReason: isExpired(empComp.valid_to)
        ? 'Utgången giltighet'
        : null,
      isSafetyCritical: compInfo.is_safety_critical,
    });
  }

  // 8) Summary / risk score
  const coveragePercent =
    totalRequired === 0
      ? 100
      : Math.round(((totalRequired - gapCount) / totalRequired) * 100);

  let riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' = 'LOW';
  if (gapCount === 0) {
    riskLevel = 'LOW';
  } else if (gapCount <= 2) {
    riskLevel = 'MEDIUM';
  } else {
    riskLevel = 'HIGH';
  }

  // Sortera per grupp + namn
  items.sort((a, b) => {
    const g1 = a.groupName ?? '';
    const g2 = b.groupName ?? '';
    if (g1 !== g2) return g1.localeCompare(g2);
    return a.competenceName.localeCompare(b.competenceName);
  });

  return {
    employee: {
      id: employeeRow.id,
      name: employeeName,
      positionName,
    },
    summary: {
      riskLevel,
      gapCount,
      totalRequired,
      coveragePercent,
      expiredCount,
    },
    items,
  };
}
